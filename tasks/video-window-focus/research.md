# Research: Video Window Focus Tracking

- **Three-layer rule** – The architecture guide keeps NSWindow plumbing out of SwiftUI views. Presentation code (like `VideoWindowChromeView`) should only consume state exposed by bridge-layer models. Direct NotificationCenter wiring inside a view would violate the "No Skip" rule in `docs/MACAMP_ARCHITECTURE_GUIDE.md:120-144`.
- **WindowAccessor is the sanctioned NSWindow escape hatch** – `docs/MACAMP_ARCHITECTURE_GUIDE.md:2368-2418` shows how SwiftUI views request their `NSWindow` once, configure it, and then hand control to bridge components (WindowSnapManager, DockingController). Any long-lived window logic (focus, persistence) is expected to live beside those bridge utilities, not in the view struct.
- **Per-window state lives in dedicated @Observable models** – `docs/README_MULTI_WINDOW.md:180-209` codifies the "Per-Window State Model" pattern. Views read focus/visibility flags through `@Environment` or injected state objects; mutation flows through @MainActor models for Swift 6 compliance.
- **WindowCoordinator already multiplexes NSWindowDelegate events** – `MacAmpApp/ViewModels/WindowCoordinator.swift:220-268` installs a `WindowDelegateMultiplexer` for each window so multiple observers (WindowSnapManager, persistence, future focus delegates) can receive `windowDidBecomeKey`/`windowDidResignKey`.
- **Delegate multiplexing exists specifically to add focus/z-order handlers later** – `MacAmpApp/Utilities/WindowDelegateMultiplexer.swift:3-86` forwards `windowDidBecomeKey`/`windowDidResignKey` events. Thread-safe focus tracking should plug a new delegate into this pipeline instead of attaching NotificationCenter observers inside views.
- **Existing NSWindow-derived state already flows through the bridge** – `WindowPersistenceDelegate` ( `MacAmpApp/ViewModels/WindowCoordinator.swift:1082-1122` ) listens for `windowDidMove/_DidResize` and updates `WindowFrameStore`. This is the precedent for converting NSWindow info into observable state, reinforcing that focus should use the same pattern.
- **Current Video window view still carries a TODO** – `MacAmpApp/Views/Windows/VideoWindowChromeView.swift:17-148` defines a `WindowFocusObserver` inside the view and leaves a `.onAppear` TODO noting that focus wiring is unsolved. This confirms the feature gap we need to resolve architecturally.
