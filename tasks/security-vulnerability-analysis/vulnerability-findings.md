# Security Vulnerability Findings

## Critical Vulnerabilities

### 1. ZIP Archive Path Traversal (CVSS: 9.8 - Critical)
**File**: `SkinManager.swift:293-310`, `SkinManager.swift:313-325`
**Attack Vector**: Local file system access through malicious ZIP archives

**Vulnerability**:
```swift
// SkinManager.swift:298-300
let afterSlash = lowerPath.components(separatedBy: "/").last ?? lowerPath
let file = afterSlash.components(separatedBy: "\\").last ?? afterSlash
```

**Issue**: The code extracts the filename from ZIP entries but doesn't validate for path traversal sequences like `../../../` or absolute paths. A malicious ZIP could contain entries like `../../../../../../../../etc/passwd` that could overwrite system files when extracted.

**Exploitation Scenario**:
1. Attacker creates malicious .wsz file with path traversal entries
2. User imports the skin file
3. During extraction, files could be written outside the intended extraction directory
4. System files could be overwritten or created

**Recommended Fix**:
```swift
private func validateZipEntry(_ entry: Entry) -> Bool {
    let path = entry.path
    
    // Check for path traversal attempts
    if path.contains("../") || path.contains("..\\") {
        return false
    }
    
    // Check for absolute paths
    if path.hasPrefix("/") || path.hasPrefix("\\") {
        return false
    }
    
    // Check for null bytes
    if path.contains("\0") {
        return false
    }
    
    // Normalize and verify still within bounds
    let normalized = (path as NSString).standardizingPath
    return !normalized.hasPrefix("/") && !normalized.contains("..")
}
```

### 2. Unlimited ZIP Archive Size (CVSS: 8.6 - High)
**File**: `SkinManager.swift:332`, `SkinManager.swift:387-388`
**Attack Vector**: Denial of Service through resource exhaustion

**Vulnerability**:
```swift
let archive = try Archive(url: url, accessMode: .read)
var data = Data()
_ = try archive.extract(entry, consumer: { data.append($0) })
```

**Issue**: No limits on archive size, individual file sizes, or total extracted data. A malicious ZIP could contain gigabytes of compressed data that expand to terabytes, exhausting memory and disk space.

**Exploitation Scenario**:
1. Attacker creates ZIP with 1GB of highly compressible data (e.g., all zeros)
2. When extracted, it expands to 100GB+ of data
3. Application crashes from memory exhaustion
4. User's disk space is consumed

**Recommended Fix**:
```swift
private static let MAX_ARCHIVE_SIZE = 100 * 1024 * 1024 // 100MB
private static let MAX_FILE_SIZE = 10 * 1024 * 1024    // 10MB per file
private static let MAX_TOTAL_EXTRACTED = 50 * 1024 * 1024 // 50MB total

func loadSkin(from url: URL) {
    // Check file size before opening
    guard let fileSize = try? FileManager.default.attributesOfItem(atPath: url.path)[.size] as? Int64,
          fileSize <= MAX_ARCHIVE_SIZE else {
        loadingError = "Skin file too large"
        return
    }
    
    var totalExtracted = 0
    // ... in extraction loop:
    guard data.count <= MAX_FILE_SIZE else {
        throw NSError(domain: "SkinError", code: 1, userInfo: [NSLocalizedDescriptionKey: "File too large"])
    }
    totalExtracted += data.count
    guard totalExtracted <= MAX_TOTAL_EXTRACTED else {
        throw NSError(domain: "SkinError", code: 2, userInfo: [NSLocalizedDescriptionKey: "Archive too large"])
    }
}
```

### 3. Image Processing Buffer Overflow (CVSS: 8.2 - High)
**File**: `ImageSlicing.swift:7-27`, `SkinManager.swift:406-407`
**Attack Vector**: Memory corruption through malicious image files

**Vulnerability**:
```swift
// ImageSlicing.swift:14-18
let imageBounds = CGRect(x: 0, y: 0, width: CGFloat(cgImage.width), height: CGFloat(cgImage.height))
if !imageBounds.contains(rect) && !imageBounds.intersects(rect) {
    print("❌ ImageSlicing: Rect \(rect) is outside image bounds \(imageBounds)")
    return nil
}
```

**Issue**: The bounds check has a logic error - it returns nil only if the rect is BOTH outside AND doesn't intersect. A rect that partially intersects but extends outside bounds will pass the check, potentially causing buffer overflows in CGImage.cropping.

**Exploitation Scenario**:
1. Attacker creates BMP with malicious dimensions or corrupted headers
2. Sprite coordinates reference areas outside the actual image data
3. CGImage.cropping attempts to access invalid memory
4. Application crashes or potential code execution

**Recommended Fix**:
```swift
func cropped(to rect: CGRect) -> NSImage? {
    guard let cgImage = self.cgImage(forProposedRect: nil, context: nil, hints: nil) else {
        return nil
    }
    
    let imageBounds = CGRect(x: 0, y: 0, width: CGFloat(cgImage.width), height: CGFloat(cgImage.height))
    
    // Proper bounds checking - rect must be completely within image bounds
    guard imageBounds.contains(rect) else {
        print("❌ ImageSlicing: Rect \(rect) is outside image bounds \(imageBounds)")
        return nil
    }
    
    // Additional validation for reasonable dimensions
    guard rect.width > 0 && rect.height > 0 && 
          rect.width <= 10000 && rect.height <= 10000 else {
        print("❌ ImageSlicing: Invalid rect dimensions \(rect)")
        return nil
    }
    
    guard let croppedCGImage = cgImage.cropping(to: rect) else {
        return nil
    }
    
    return NSImage(cgImage: croppedCGImage, size: rect.size)
}
```

## High Vulnerabilities

### 4. Text Parser Injection (CVSS: 7.5 - High)
**File**: `PLEditParser.swift:12-24`, `VisColorParser.swift:10-16`
**Attack Vector**: Code injection through malformed configuration files

**Vulnerability**:
```swift
// PLEditParser.swift:12
for rawLine in text.replacingOccurrences(of: "\r", with: "").components(separatedBy: "\n") {
    let line = rawLine.trimmingCharacters(in: .whitespaces)
    if line.isEmpty || line.hasPrefix(";") { continue }
```

**Issue**: No validation of line length, character encoding, or content. Extremely long lines could cause memory exhaustion, and special characters could interfere with string processing.

**Exploitation Scenario**:
1. Attacker creates PLEDIT.TXT with 1MB lines
2. String processing consumes excessive memory
3. Application becomes unresponsive or crashes

**Recommended Fix**:
```swift
private static let MAX_LINE_LENGTH = 1024
private static let MAX_LINES = 1000

static func parse(from data: Data) -> PlaylistStyle? {
    guard data.count <= MAX_FILE_SIZE else { return nil }
    
    guard let text = String(data: data, encoding: .utf8) ?? String(data: data, encoding: .windowsCP1252) else {
        return nil
    }
    
    var lineCount = 0
    for rawLine in text.replacingOccurrences(of: "\r", with: "").components(separatedBy: "\n") {
        lineCount += 1
        guard lineCount <= MAX_LINES else { return nil } // Too many lines
        
        let line = rawLine.trimmingCharacters(in: .whitespaces)
        guard line.count <= MAX_LINE_LENGTH else { continue } // Skip overly long lines
        
        // ... rest of parsing
    }
}
```

### 5. Binary Parser Integer Overflow (CVSS: 7.0 - High)
**File**: `EQF.swift:15-53`
**Attack Vector**: Memory corruption through malformed EQF files

**Vulnerability**:
```swift
// EQF.swift:18
guard bytes.count >= header.count + 4 + nameFieldLength + presetValueCount else { return nil }
// EQF.swift:25
guard i + nameFieldLength + presetValueCount <= bytes.count else { return nil }
```

**Issue**: Integer arithmetic could overflow if bytes.count is close to Int.max, and no validation of individual field values before array access.

**Exploitation Scenario**:
1. Attacker creates EQF file with corrupted length fields
2. Integer calculations overflow
3. Array access with invalid indices
4. Memory corruption or crash

**Recommended Fix**:
```swift
static func parse(data: Data) -> EqfPreset? {
    guard data.count <= MAX_EQF_SIZE else { return nil }
    
    var i = 0
    let bytes = [UInt8](data)
    
    // Safe arithmetic with overflow checks
    guard let headerEnd = Int(exactly: header.count),
          let controlEnd = headerEnd.addingReportingOverflow(4).partialValue,
          let nameEnd = controlEnd.addingReportingOverflow(nameFieldLength).partialValue,
          let totalEnd = nameEnd.addingReportingOverflow(presetValueCount).partialValue,
          totalEnd <= bytes.count else {
        return nil
    }
    
    // ... rest of parsing with bounds checks
}
```

## Medium Vulnerabilities

### 6. Memory Exhaustion in Image Loading (CVSS: 6.5 - Medium)
**File**: `SkinManager.swift:389`
**Attack Vector**: Denial of Service through large images

**Vulnerability**:
```swift
guard let sheetImage = NSImage(data: data) else {
```

**Issue**: No validation of image dimensions before loading NSImage. Malicious BMP files could claim enormous dimensions, causing memory allocation failures.

**Recommended Fix**:
```swift
// Validate image data size first
guard data.count <= MAX_IMAGE_DATA_SIZE else {
    NSLog("❌ Image data too large: \(data.count) bytes")
    continue
}

// Try to get image dimensions without fully loading
if let imageSource = CGImageSourceCreateWithData(data as CFData, nil),
   let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any],
   let width = properties[kCGImagePropertyPixelWidth] as? Int,
   let height = properties[kCGImagePropertyPixelHeight] as? Int {
    guard width <= MAX_IMAGE_WIDTH && height <= MAX_IMAGE_HEIGHT else {
        NSLog("❌ Image dimensions too large: \(width)x\(height)")
        continue
    }
}

guard let sheetImage = NSImage(data: data) else {
```

### 7. Uncontrolled Resource Consumption (CVSS: 6.2 - Medium)
**File**: `SkinManager.swift:369-431`
**Attack Vector**: CPU exhaustion through complex processing

**Vulnerability**: No limits on number of sprites or processing time. Archives with thousands of sprites could cause excessive CPU usage.

**Recommended Fix**:
```swift
private static let MAX_SPRITES_PER_SHEET = 1000
private static let PROCESSING_TIMEOUT: TimeInterval = 30.0

// Add timeout checking
let startTime = Date()
for (sheetName, sprites) in sheetsToProcess {
    guard Date().timeIntervalSince(startTime) < PROCESSING_TIMEOUT else {
        throw NSError(domain: "SkinError", code: 3, userInfo: [NSLocalizedDescriptionKey: "Processing timeout"])
    }
    
    guard sprites.count <= MAX_SPRITES_PER_SHEET else {
        NSLog("⚠️ Too many sprites in sheet \(sheetName): \(sprites.count)")
        continue
    }
    // ... processing
}
```

## Low Vulnerabilities

### 8. Information Disclosure (CVSS: 4.3 - Low)
**File**: `SkinManager.swift:528-534`
**Attack Vector**: Sensitive information in error messages

**Vulnerability**: Error messages may expose file paths and system information.

**Recommended Fix**:
```swift
} catch {
    NSLog("Error loading skin: \(error)") // Keep detailed logging for debugging
    loadingError = "Failed to load skin file" // User-friendly message without details
    isLoading = false
}
```

### 9. Missing Input Validation (CVSS: 3.7 - Low)
**File**: `VisColorParser.swift:13-14`
**Attack Vector**: Invalid color values

**Vulnerability**: No validation that color values are within 0-255 range.

**Recommended Fix**:
```swift
if parts.count >= 3, 
   let r = Double(parts[0]), let g = Double(parts[1]), let b = Double(parts[2]),
   r >= 0 && r <= 255, g >= 0 && g <= 255, b >= 0 && b <= 255 {
    let color = Color(.sRGB, red: r/255.0, green: g/255.0, blue: b/255.0, opacity: 1)
    colors.append(color)
}
```

## macOS-Specific Security Considerations

### Sandbox Compliance
The current entitlements are appropriately restrictive:
- ✅ No JIT or unsigned executable memory
- ✅ No automation Apple Events
- ✅ Limited file system access
- ✅ Network client only (no server)

### Recommendations
1. **Enable App Sandbox**: Ensure sandbox is enabled in build settings
2. **Code Signing**: Maintain proper code signing for distribution
3. **Library Validation**: Keep disabled library validation disabled (current setting is correct)
4. **Hardened Runtime**: Current settings are appropriate

## Summary

**Critical**: 1 vulnerability (Path Traversal)
**High**: 4 vulnerabilities (Resource exhaustion, buffer overflows, injection)
**Medium**: 2 vulnerabilities (Memory exhaustion, CPU exhaustion)
**Low**: 2 vulnerabilities (Information disclosure, input validation)

**Priority Actions**:
1. Fix ZIP path traversal immediately (Critical)
2. Add file size limits (High)
3. Fix image bounds checking (High)
4. Add input validation for parsers (High)

The codebase benefits from Swift's memory safety features but still has several critical security issues that need immediate attention, particularly around file processing and input validation.