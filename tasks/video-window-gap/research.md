# Research: Video Window gap + metadata growth + resize jitter

## Code inspection
- `MacAmpApp/Views/Windows/VideoWindowChromeView.swift` defines all chrome placement in a `ZStack(alignment: .topLeading)` with fixed constants for left/right borders (`11` / `8` pts), bottom sections (`125` pts each), and the center tile run quantized by 25 px segments (lines 3-167). Every sprite uses `.position(x:y:)` with its center set to `width / 2` away from the target edge, so the math assumes the stack’s origin is the top-left corner of the NSWindow content view.
- Vertical borders are tiled via `ForEach` and placed at `x: 5.5` (`11 / 2`) for the left strip and `x: pixelSize.width - 4` (`width - 8 / 2`) for the right strip (lines 133-144). The first tile’s Y is `20 + 14.5`, so the border is meant to sit flush under the 20 px titlebar.
- Bottom bar layout pins the left 125 px sprite to center `62.5`, renders `centerTileCount` 25 px tiles, and leaves the right 125 px sprite centered at `pixelSize.width - 62.5` (lines 149-167). There is currently no logic that reallocates the extra width that `centerTileCount` represents—every additional 25 px segment created by resizing is routed into the filler tiles, so the metadata sprite always stays 125 px wide regardless of window width.
- Metadata glyphs are drawn with TEXT.bmp sprites and clipped to `displayWidth = 115` (lines 169-199). That constant assumes the backing sprite is 125 px wide with a 5 px inset on each side.
- `SimpleSpriteImage` renders `NSImage` sprites via `.resizable().aspectRatio(.fill)` inside a `.frame(width:height:)` for exact dimensions (Views/Components/SimpleSpriteImage.swift:27-70). There’s no implicit padding; the rendered rect should match what `.position` computes.
- `VideoWindowSizeState` exposes `pixelSize`, `contentSize`, and `centerWidth = max(0, pixelSize.width - 250)` (Models/VideoWindowSizeState.swift:21-63). Because `centerWidth` subtracts the two 125 px end caps up front, every extra 25 px unit from resizing is consumed by the `VIDEO_BOTTOM_TILE` run.
- `WinampVideoWindow` wraps the chrome view in a `.frame(width: sizeState.pixelSize.width, height: sizeState.pixelSize.height, alignment: .topLeading)` and mirrors those dimensions into the NSWindow by calling `WindowCoordinator.updateVideoWindowSize()` whenever `sizeState.size` changes (Views/WinampVideoWindow.swift:47-66).
- `WindowCoordinator.updateVideoWindowSize` keeps the top-left corner fixed by reassigning `frame.size` and recomputing `frame.origin` based on the stored top-left point (ViewModels/WindowCoordinator.swift:719-728). AppKit resizing therefore never inserts extra padding; any gap has to originate from SwiftUI layout values.
- The drag gesture driving resize is implemented directly inside `VideoWindowChromeView`. It captures `dragStartSize`, rounds translations toward zero in 25×29 px quantized increments, and only mutates `sizeState` when a whole segment boundary is crossed (lines 272-307). Each drag tick toggles `WindowSnapManager`’s `beginProgrammaticAdjustment` flag to suppress cluster snapping while the user is dragging (Utilities/WindowSnapManager.swift:28-69).

## Observations / hypotheses
- Because both the root `ZStack` and the outer `.frame` call use `.topLeading` alignment, the only way to get a left-side “gap” while everything is positioned via `.position` is if one of the coordinate assumptions is wrong. The most likely culprit is that the hosting stack’s origin isn’t truly `(0,0)` relative to the NSWindow backing layer. If the `NSHostingView` introduces an implicit safe-area inset (e.g., because AppKit still reserves 1 pt inside borderless windows), then positioning everything from `x = width / 2` leaves that inset visible. There’s no compensating offset, so the sprites start rendering at `x = inset` instead of screen `x = 0`, creating the gap.
- Another possibility is retina rounding: `VideoWindowChromeView` mixes odd-width sprites (11 px) with even sized frames, so when the host window lands on a half-point coordinate the center-based `.position` math produces fractional pixel edges. The `Color.black` background still fills the true window bounds, but the sprite edges end up at `x = inset ± 0.5`, which looks like a bright seam under magnification. Because nothing clamps `NSWindow` frame origins to device pixels, dragging to arbitrary positions can leave the whole chrome at a +0.5 offset horizontally, which matches the screenshot description (gap visible at every size, not just “bad math” sizes).
- Metadata layout has no awareness of total window width. Even if we stretch the right sprite, the `displayWidth` hard limit (115 px) enforces scrolling at most sizes. The center filler is purely cosmetic, so reallocating parts of `centerWidth` to metadata would have minimal UX impact but a large readability gain.
- Resize “jitter” reports persist even though we quantize and suppress snap manager updates. The remaining oscillations are likely caused by SwiftUI recomputing the entire `VideoWindowChromeView` body on every `sizeState` mutation while the NSWindow simultaneously animates to the new size. Without throttling, the binding loops look like: gesture tick → `sizeState` change → SwiftUI re-layout → `.onChange` fires → `WindowCoordinator` sets AppKit frame → AppKit notifies SwiftUI about geometry changes. If the user drags slowly, this produces an alternating sequence of “SwiftUI resized, AppKit still catching up” frames that feel jittery.
- Because drag translation is rounded with `.towardZero`, hovering near a tile boundary rapidly toggles between two sizes as the rounded value bounces between `n` and `n±1`. There’s no hysteresis, so half-pixel noise from trackpads can churn between sizes even when the pointer looks stationary. That symptom matches the “jerky” bug report.

## Open questions / data still needed
- Need confirmation on whether NSWindow frames are landing on ±0.5 coordinates; the screenshot seems to suggest so. AppKit logging of `video.frame.origin.x` during drag would confirm.
- We need product direction on how far the metadata block is allowed to grow before the center filler returns. Is the goal “give all extra width to metadata forever” or “stop at some visual max so the right cap doesn’t look stretched relative to the left”?
- For jitter fixes, we have multiple levers (snap `NSWindow` origins to integral points, add drag hysteresis, throttle updates). Clarifying which trade-off (visual snapping vs. slower resize) is acceptable will guide the implementation.
