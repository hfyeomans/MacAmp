# Research - Code Review Sweep

- Reviewed the full docs set under `docs/` (README index, MACAMP_ARCHITECTURE_GUIDE, IMPLEMENTATION_PATTERNS, SPRITE_SYSTEM_COMPLETE, multi-window suite, VIDEO_WINDOW, MILKDROP_WINDOW, WINDOW_FOCUS_ARCHITECTURE, CUSTOM_DRAG_FIX, WINAMP_SKIN_VARIATIONS, release/signing guides, and session notes) to map architecture and standards.
- Architecture: strict three-layer split (mechanism → bridge → presentation), dual audio backend (AudioPlayer for local/EQ, StreamPlayer for streams) orchestrated by PlaybackCoordinator, @Observable @MainActor models across UI, and semantic sprite system resolving skin assets with fallbacks.
- Multi-window: preferred pure SwiftUI `WindowGroup(id:)` per window with per-window state models plus shared globals injected via environment; WindowStateStore persists frames; WindowAccessor + WindowSnapManager provide magnetic docking and cluster movement; window focus tracked via WindowFocusState + WindowFocusDelegate for active/inactive chrome.
- Window chrome: Video and Milkdrop windows use Winamp-style sprite chrome (VIDEO.bmp, GEN.bmp) with precise sizing (275×232) and AppKit controllers wrapping SwiftUI; resizing/docking integrated with snap manager; focus states drive active titlebar rendering.
- Interaction systems: Custom drag pipeline replaces `WindowDragGesture`, capturing base positions for clusters and applying cumulative deltas; playlist/menu patterns rely on SpriteMenuItem and menu delegates; clutter bar buttons drive toggles (double size, always-on-top, options, track info, video/milkdrop visibility).
- Skinning: Semantic sprites mapped via `SpriteResolver` to NUMBERS/NUMS_EX variants and other BMP atlases; fallback generation ensures missing assets don’t crash; hot skin swapping supported.
- Build/distribution: Release builds rely on scheme post-actions to copy signed app to `dist/`; code signing verification expected; hardened runtime/notarization outlined in release and signing docs.
- Standards emphasized: Swift 6 concurrency, main-actor UI updates, explicit sizing for titlebar drag hit areas, preference for functional SwiftUI patterns, and avoidance of deprecated APIs or ad-hoc debug logging.
